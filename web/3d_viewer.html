<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>625 Ocean Street ‚Äî 3D Model Viewer</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{background:#0a0e14;overflow:hidden;font-family:system-ui}
canvas{display:block}
#controls{position:fixed;top:16px;left:16px;z-index:10;display:flex;flex-direction:column;gap:8px}
.ctrl-btn{background:rgba(14,22,38,0.85);border:1px solid rgba(78,205,196,0.3);color:#e0e8f0;padding:8px 14px;border-radius:8px;cursor:pointer;font-size:12px;font-family:'Segoe UI',system-ui;transition:all 0.2s;backdrop-filter:blur(10px)}
.ctrl-btn:hover{border-color:#4ecdc4;background:rgba(78,205,196,0.1)}
.ctrl-btn.active{border-color:#4ecdc4;background:rgba(78,205,196,0.15);color:#4ecdc4}
#info{position:fixed;bottom:16px;left:16px;z-index:10;background:rgba(14,22,38,0.85);border:1px solid rgba(26,42,64,0.8);border-radius:10px;padding:12px 16px;backdrop-filter:blur(10px);color:#90a8c0;font-size:11px;line-height:1.6}
#info strong{color:#4ecdc4}
#title{position:fixed;top:16px;right:16px;z-index:10;text-align:right}
#title h1{font-size:18px;font-weight:800;color:#f0f4f8;margin-bottom:2px}
#title p{font-size:11px;color:#5a7090}
#loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#0a0e14;z-index:100;transition:opacity 0.5s}
#loading.hidden{opacity:0;pointer-events:none}
#loading span{font-size:16px;color:#4ecdc4;font-weight:600}
</style>
</head>
<body>

<div id="loading"><span>Loading 625 Ocean Street...</span></div>

<div id="controls">
  <button class="ctrl-btn active" onclick="setView('orbit')" id="btn-orbit">üîÑ Orbit</button>
  <button class="ctrl-btn" onclick="setView('front')" id="btn-front">üè† East (Ocean)</button>
  <button class="ctrl-btn" onclick="setView('side')" id="btn-side">üìê South (Street)</button>
  <button class="ctrl-btn" onclick="setView('top')" id="btn-top">ü¶Ö Bird's Eye</button>
  <button class="ctrl-btn" onclick="setView('walk')" id="btn-walk">üö∂ Walkthrough</button>
  <button class="ctrl-btn" onclick="toggleAutoRotate()">‚ü≥ Auto-Rotate</button>
  <button class="ctrl-btn" onclick="toggleWireframe()">‚óª Wireframe</button>
  <button class="ctrl-btn" onclick="toggleFloors()">üìä Toggle Floors</button>
</div>

<div id="title">
  <h1>625 Ocean Street</h1>
  <p>3-Story Residence ‚Ä¢ Satellite Beach, FL</p>
</div>

<div id="info">
  <strong>Mouse:</strong> Drag to rotate ‚Ä¢ Scroll to zoom ‚Ä¢ Right-drag to pan<br>
  <strong>Floors:</strong> Level 1 (3.0m) + Level 2 (2.7m) + Level 3 (2.4m) = 8.1m total<br>
  <strong>Walls:</strong> 213 detected segments ‚Ä¢ Auto-generated from EDC floor plans
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x0a1520);
scene.fog = new THREE.Fog(0x0a1520, 80, 200);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(40, 25, 40);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;
document.body.appendChild(renderer.domElement);

// Orbit Controls (manual implementation since we can't import OrbitControls from CDN)
let isMouseDown = false;
let mouseButton = -1;
let prevMouseX = 0, prevMouseY = 0;
let spherical = { radius: 55, phi: Math.PI / 3.5, theta: Math.PI / 4 };
let target = new THREE.Vector3(0, 4, 0);
let autoRotate = true;
let autoRotateSpeed = 0.003;

document.addEventListener('mousedown', (e) => {
  isMouseDown = true;
  mouseButton = e.button;
  prevMouseX = e.clientX;
  prevMouseY = e.clientY;
  autoRotate = false;
});

document.addEventListener('mousemove', (e) => {
  if (!isMouseDown) return;
  const dx = e.clientX - prevMouseX;
  const dy = e.clientY - prevMouseY;
  
  if (mouseButton === 0) { // Left: rotate
    spherical.theta -= dx * 0.005;
    spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi - dy * 0.005));
  } else if (mouseButton === 2) { // Right: pan
    const right = new THREE.Vector3();
    const up = new THREE.Vector3(0, 1, 0);
    right.crossVectors(camera.getWorldDirection(new THREE.Vector3()), up).normalize();
    target.add(right.multiplyScalar(-dx * 0.05));
    target.y += dy * 0.05;
  }
  
  prevMouseX = e.clientX;
  prevMouseY = e.clientY;
});

document.addEventListener('mouseup', () => { isMouseDown = false; });
document.addEventListener('contextmenu', (e) => e.preventDefault());

document.addEventListener('wheel', (e) => {
  spherical.radius = Math.max(10, Math.min(120, spherical.radius + e.deltaY * 0.05));
});

// Touch support
document.addEventListener('touchstart', (e) => {
  if (e.touches.length === 1) {
    isMouseDown = true;
    mouseButton = 0;
    prevMouseX = e.touches[0].clientX;
    prevMouseY = e.touches[0].clientY;
    autoRotate = false;
  }
});
document.addEventListener('touchmove', (e) => {
  if (!isMouseDown || e.touches.length !== 1) return;
  const dx = e.touches[0].clientX - prevMouseX;
  const dy = e.touches[0].clientY - prevMouseY;
  spherical.theta -= dx * 0.005;
  spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi - dy * 0.005));
  prevMouseX = e.touches[0].clientX;
  prevMouseY = e.touches[0].clientY;
});
document.addEventListener('touchend', () => { isMouseDown = false; });

// Lighting
const ambientLight = new THREE.AmbientLight(0x404060, 0.6);
scene.add(ambientLight);

const sunLight = new THREE.DirectionalLight(0xfff0d0, 1.8);
sunLight.position.set(30, 40, 20);
sunLight.castShadow = true;
sunLight.shadow.mapSize.width = 2048;
sunLight.shadow.mapSize.height = 2048;
sunLight.shadow.camera.near = 1;
sunLight.shadow.camera.far = 100;
sunLight.shadow.camera.left = -40;
sunLight.shadow.camera.right = 40;
sunLight.shadow.camera.top = 40;
sunLight.shadow.camera.bottom = -40;
scene.add(sunLight);

const fillLight = new THREE.DirectionalLight(0x8090c0, 0.4);
fillLight.position.set(-20, 15, -10);
scene.add(fillLight);

// Ground plane
const groundGeo = new THREE.PlaneGeometry(200, 200);
const groundMat = new THREE.MeshStandardMaterial({ 
  color: 0x1a2a1a, roughness: 0.9, metalness: 0.0
});
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.05;
ground.receiveShadow = true;
scene.add(ground);

// Grid
const grid = new THREE.GridHelper(100, 50, 0x1a3040, 0x0f1f2f);
grid.position.y = 0.01;
scene.add(grid);

// Materials
const materials = {
  level1: new THREE.MeshStandardMaterial({ 
    color: 0xd4c8b0, roughness: 0.65, metalness: 0.05,
    side: THREE.DoubleSide
  }),
  level2: new THREE.MeshStandardMaterial({ 
    color: 0xc0b8a0, roughness: 0.65, metalness: 0.05,
    side: THREE.DoubleSide
  }),
  level3: new THREE.MeshStandardMaterial({ 
    color: 0xb0a890, roughness: 0.65, metalness: 0.05,
    side: THREE.DoubleSide
  }),
  floor: new THREE.MeshStandardMaterial({ 
    color: 0x8a7a60, roughness: 0.8, metalness: 0.0,
    side: THREE.DoubleSide
  }),
  wireframe: new THREE.MeshBasicMaterial({ 
    color: 0x4ecdc4, wireframe: true, transparent: true, opacity: 0.6
  })
};

// Parse OBJ data embedded
const floorGroups = [];
let wireframeMode = false;
let floorsVisible = [true, true, true];

function parseOBJAndBuild(objText, material, groupName) {
  const vertices = [];
  const faces = [];
  const lines = objText.split('\n');
  
  for (const line of lines) {
    const parts = line.trim().split(/\s+/);
    if (parts[0] === 'v') {
      vertices.push(parseFloat(parts[1]), parseFloat(parts[2]), parseFloat(parts[3]));
    } else if (parts[0] === 'f') {
      const indices = parts.slice(1).map(v => parseInt(v.split('/')[0]) - 1);
      if (indices.length === 3) {
        faces.push(...indices);
      } else if (indices.length === 4) {
        faces.push(indices[0], indices[1], indices[2]);
        faces.push(indices[0], indices[2], indices[3]);
      }
    }
  }
  
  const geometry = new THREE.BufferGeometry();
  geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
  geometry.setIndex(faces);
  geometry.computeVertexNormals();
  
  const mesh = new THREE.Mesh(geometry, material);
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  mesh.name = groupName;
  scene.add(mesh);
  
  return mesh;
}

// Load OBJ files from repo
async function loadModels() {
  const baseUrl = 'https://raw.githubusercontent.com/breverdbidder/625-ocean-ave-maket-guide/master/blender_3d/';
  const fallbackUrl = '';
  
  const floorConfigs = [
    { file: 'Level1_First_Floor.obj', material: materials.level1, name: 'Level 1' },
    { file: 'Level2_Second_Floor.obj', material: materials.level2, name: 'Level 2' },
    { file: 'Level3_Third_Floor.obj', material: materials.level3, name: 'Level 3' }
  ];
  
  // Try loading from GitHub, fall back to embedded demo
  for (const config of floorConfigs) {
    try {
      const response = await fetch(baseUrl + config.file);
      if (response.ok) {
        const objText = await response.text();
        const mesh = parseOBJAndBuild(objText, config.material, config.name);
        floorGroups.push(mesh);
        continue;
      }
    } catch(e) {}
    
    // Generate demo geometry if fetch fails
    console.log(`Generating demo geometry for ${config.name}`);
    const group = generateDemoFloor(config.name, config.material);
    floorGroups.push(group);
  }
  
  document.getElementById('loading').classList.add('hidden');
}

function generateDemoFloor(name, material) {
  // Generate approximate 625 Ocean floor structure
  const group = new THREE.Group();
  group.name = name;
  
  let yOffset = 0;
  let height = 3.0;
  
  if (name === 'Level 2') { yOffset = 3.0; height = 2.7; }
  if (name === 'Level 3') { yOffset = 5.7; height = 2.4; }
  
  // Approximate house dimensions: 118' x 28' (from plans)
  const houseL = 36; // ~118 ft in meters
  const houseW = 8.5;  // ~28 ft in meters
  const wallT = 0.2;
  
  // Outer walls
  const walls = [
    // Front wall (south - street side)
    { x: 0, z: 0, w: houseL, d: wallT },
    // Back wall (north - ocean side)  
    { x: 0, z: houseW, w: houseL, d: wallT },
    // Left wall (west)
    { x: 0, z: 0, w: wallT, d: houseW },
    // Right wall (east)
    { x: houseL - wallT, z: 0, w: wallT, d: houseW },
  ];
  
  // Interior walls (approximated from plans)
  const interiorPositions = [
    // Garage partition
    { x: 8, z: 0, w: wallT, d: houseW * 0.55 },
    // Entry foyer
    { x: 14, z: 0, w: wallT, d: houseW * 0.6 },
    // Living areas divisions
    { x: 20, z: 0, w: wallT, d: houseW },
    { x: 26, z: 0, w: wallT, d: houseW },
    // Cross walls
    { x: 8, z: houseW * 0.55, w: 12, d: wallT },
    { x: 26, z: houseW * 0.5, w: 10, d: wallT },
  ];
  
  const allWalls = [...walls, ...interiorPositions];
  
  for (const w of allWalls) {
    const geo = new THREE.BoxGeometry(w.w, height, w.d);
    const mesh = new THREE.Mesh(geo, material);
    mesh.position.set(
      w.x + w.w/2 - houseL/2,
      yOffset + height/2,
      w.z + w.d/2 - houseW/2
    );
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    group.add(mesh);
  }
  
  // Floor plate
  const floorGeo = new THREE.BoxGeometry(houseL, 0.15, houseW);
  const floorMesh = new THREE.Mesh(floorGeo, materials.floor);
  floorMesh.position.set(0, yOffset, 0);
  floorMesh.receiveShadow = true;
  group.add(floorMesh);
  
  scene.add(group);
  return group;
}

// View presets
function setView(preset) {
  document.querySelectorAll('.ctrl-btn').forEach(b => b.classList.remove('active'));
  
  switch(preset) {
    case 'orbit':
      spherical = { radius: 55, phi: Math.PI / 3.5, theta: Math.PI / 4 };
      target.set(0, 4, 0);
      document.getElementById('btn-orbit').classList.add('active');
      break;
    case 'front':
      spherical = { radius: 50, phi: Math.PI / 2.2, theta: 0 };
      target.set(0, 4, 0);
      document.getElementById('btn-front').classList.add('active');
      break;
    case 'side':
      spherical = { radius: 50, phi: Math.PI / 2.2, theta: Math.PI / 2 };
      target.set(0, 4, 0);
      document.getElementById('btn-side').classList.add('active');
      break;
    case 'top':
      spherical = { radius: 60, phi: 0.2, theta: 0 };
      target.set(0, 0, 0);
      document.getElementById('btn-top').classList.add('active');
      break;
    case 'walk':
      spherical = { radius: 15, phi: Math.PI / 2.5, theta: Math.PI / 6 };
      target.set(0, 2, 0);
      document.getElementById('btn-walk').classList.add('active');
      break;
  }
}

function toggleAutoRotate() {
  autoRotate = !autoRotate;
  event.target.classList.toggle('active', autoRotate);
}

function toggleWireframe() {
  wireframeMode = !wireframeMode;
  event.target.classList.toggle('active', wireframeMode);
  
  floorGroups.forEach((mesh, i) => {
    if (mesh.isMesh) {
      mesh.material = wireframeMode ? materials.wireframe : 
        [materials.level1, materials.level2, materials.level3][i];
    } else if (mesh.isGroup) {
      mesh.traverse(child => {
        if (child.isMesh && child.material !== materials.floor) {
          child.material = wireframeMode ? materials.wireframe :
            [materials.level1, materials.level2, materials.level3][i];
        }
      });
    }
  });
}

function toggleFloors() {
  // Cycle through floor visibility: All ‚Üí L1 only ‚Üí L2 only ‚Üí L3 only ‚Üí All
  const current = floorsVisible.filter(v => v).length;
  if (current === 3) {
    floorsVisible = [true, false, false];
  } else if (floorsVisible[0]) {
    floorsVisible = [false, true, false];
  } else if (floorsVisible[1]) {
    floorsVisible = [false, false, true];
  } else {
    floorsVisible = [true, true, true];
  }
  
  floorGroups.forEach((mesh, i) => {
    mesh.visible = floorsVisible[i];
  });
}

// Animation loop
function animate() {
  requestAnimationFrame(animate);
  
  if (autoRotate) {
    spherical.theta += autoRotateSpeed;
  }
  
  // Update camera from spherical
  camera.position.x = target.x + spherical.radius * Math.sin(spherical.phi) * Math.sin(spherical.theta);
  camera.position.y = target.y + spherical.radius * Math.cos(spherical.phi);
  camera.position.z = target.z + spherical.radius * Math.sin(spherical.phi) * Math.cos(spherical.theta);
  camera.lookAt(target);
  
  renderer.render(scene, camera);
}

// Resize
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Start
loadModels();
animate();
</script>
</body>
</html>
